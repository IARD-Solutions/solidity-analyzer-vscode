import * as vscode from 'vscode';
import { Vulnerability, LinterResult, Category } from '../models/types';
import { RawVulnerability, RawLinterResult, ParsedLinterLine } from '../models/apiTypes';

/**
 * Processes raw vulnerability data from the API into a standardized format.
 * 
 * @param apiResult The raw vulnerability data from the API
 * @returns An array of processed vulnerabilities
 */
export function handleVulnerabilities(apiResult: RawVulnerability[]): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    apiResult.forEach((vuln, index) => {
        // Generate a unique ID if not provided
        if (!vuln.id) {
            vuln.id = `vuln-${Date.now()}-${index}`;
        }

        // Process and transform the vulnerability data as needed
        vulnerabilities.push({
            id: vuln.id,
            // Ensure check is set (required by Vulnerability interface)
            check: vuln.check || vuln.title || `Vulnerability-${index}`,
            title: vuln.title || vuln.check || 'Unnamed Vulnerability',
            description: vuln.description || 'No description provided',
            impact: vuln.impact || 'Medium',
            confidence: vuln.confidence || 'Medium',
            category: vuln.category || 'Unknown',
            function: vuln.function || '',
            detector: vuln.detector || '',
            lines: vuln.lines || []
        });
    });

    const config = vscode.workspace.getConfiguration('solidityAnalyzer');
    const analyzeNodeModules = config.get<boolean>('analyzeNodeModules');

    if (!analyzeNodeModules) {
        vulnerabilities.forEach(vuln => {
            vuln.description = vuln.description
                .split('\n')
                .filter(line => !line.includes('node_modules'))
                .join('\n');
        });
    }

    // Regular expression to extract file and line information from descriptions
    const lineRegex = /([^\s()]+\.sol)#(\d+)(?:-(\d+))?/g;

    return vulnerabilities
        .map(vuln => {
            // If lines are already properly set, don't modify them
            if (vuln.lines && vuln.lines.length > 0 &&
                vuln.lines.some(loc => loc.contract && loc.lines && loc.lines.length > 0)) {
                return vuln;
            }

            const lines: { contract: string, lines: number[] }[] = [];
            let match;
            let allRanges = [];

            // Extract file paths and line numbers from the description
            while ((match = lineRegex.exec(vuln.description)) !== null) {
                const contract = match[1];
                const startLine = parseInt(match[2], 10);
                const endLine = match[3] ? parseInt(match[3], 10) : startLine;
                const lineCount = endLine - startLine + 1;

                allRanges.push({
                    contract,
                    startLine,
                    endLine,
                    lineCount
                });
            }

            // If we found any ranges, group them by file and pick the smallest range for each file
            if (allRanges.length > 0) {
                // Group ranges by file
                const rangesByFile: Record<string, { startLine: number, endLine: number, lineCount: number }[]> = {};

                for (const range of allRanges) {
                    if (!rangesByFile[range.contract]) {
                        rangesByFile[range.contract] = [];
                    }
                    rangesByFile[range.contract].push(range);
                }

                // For each file, find the smallest range
                for (const [contract, fileRanges] of Object.entries(rangesByFile)) {
                    // Sort by line count (ascending)
                    fileRanges.sort((a, b) => a.lineCount - b.lineCount);

                    // Select the smallest range for this file
                    const smallestRange = fileRanges[0];
                    const lineNumbers = [];

                    for (let line = smallestRange.startLine; line <= smallestRange.endLine; line++) {
                        lineNumbers.push(line);
                    }

                    lines.push({ contract, lines: lineNumbers });
                }
            }

            vuln.lines = lines;
            return vuln;
        })
        .filter(vuln => vuln.lines && vuln.lines.length > 0);
}

// Map of rule IDs to categories
export const solhintCategories: Record<string, Category> = {
    // Best Practice Rules
    "code-complexity": "Best Practice",
    "explicit-types": "Best Practice",
    "function-max-lines": "Best Practice",
    "max-line-length": "Best Practice",
    "max-states-count": "Best Practice",
    "no-console": "Best Practice",
    "no-empty-blocks": "Best Practice",
    "no-global-import": "Best Practice",
    "no-unused-import": "Best Practice",
    "no-unused-vars": "Best Practice",
    "one-contract-per-file": "Best Practice",
    "payable-fallback": "Best Practice",
    "reason-string": "Best Practice",

    // Style Guide Rules
    "interface-starts-with-i": "Style Guide",
    "duplicated-imports": "Style Guide",
    "const-name-snakecase": "Style Guide",
    "contract-name-capwords": "Style Guide",
    "event-name-capwords": "Style Guide",
    "foundry-test-functions": "Style Guide",
    "func-name-mixedcase": "Style Guide",
    "func-named-parameters": "Style Guide",
    "func-param-name-mixedcase": "Style Guide",
    "immutable-vars-naming": "Style Guide",
    "modifier-name-mixedcase": "Style Guide",
    "named-parameters-mapping": "Style Guide",
    "private-vars-leading-underscore": "Style Guide",
    "use-forbidden-name": "Style Guide",
    "var-name-mixedcase": "Style Guide",
    "func-order": "Style Guide",
    "imports-on-top": "Style Guide",
    "imports-order": "Style Guide",
    "ordering": "Style Guide",
    "visibility-modifier-order": "Style Guide",

    // Gas Consumption Rules
    "gas-calldata-parameters": "Gas Consumption",
    "gas-custom-errors": "Gas Consumption",
    "gas-increment-by-one": "Gas Consumption",
    "gas-indexed-events": "Gas Consumption",
    "gas-length-in-loops": "Gas Consumption",
    "gas-multitoken1155": "Gas Consumption",
    "gas-named-return-values": "Gas Consumption",
    "gas-small-strings": "Gas Consumption",
    "gas-strict-inequalities": "Gas Consumption",
    "gas-struct-packing": "Gas Consumption",

    // Security Rules
    "avoid-call-value": "Security",
    "avoid-low-level-calls": "Security",
    "avoid-sha3": "Security",
    "avoid-suicide": "Security",
    "avoid-throw": "Security",
    "avoid-tx-origin": "Security",
    "check-send-result": "Security",
    "compiler-version": "Security",
    "func-visibility": "Security",
    "mark-callable-contracts": "Security",
    "multiple-sends": "Security",
    "no-complex-fallback": "Security",
    "no-inline-assembly": "Security",
    "not-rely-on-block-hash": "Security",
    "not-rely-on-time": "Security",
    "reentrancy": "Security",
    "state-visibility": "Security",

    // Miscellaneous
    "comprehensive-interface": "Miscellaneous",
    "quotes": "Miscellaneous"
};

/**
 * Processes raw linter data from the API into a standardized format.
 * 
 * @param linterData The raw linter data from the API as a string
 * @returns An array of processed linter results
 */
export function handleLinterResults(linterData: string): LinterResult[] {
    if (!linterData) return [];

    try {
        // First, try to parse as JSON
        try {
            const parsedData = JSON.parse(linterData);

            if (Array.isArray(parsedData)) {
                return parsedData.map((result: RawLinterResult): LinterResult => ({
                    ...result,
                    category: getRuleCategory(result.ruleId || '')
                } as LinterResult));
            } else if (parsedData.results && Array.isArray(parsedData.results)) {
                return parsedData.results.map((result: RawLinterResult): LinterResult => ({
                    ...result,
                    category: getRuleCategory(result.ruleId || '')
                } as LinterResult));
            }
        } catch (e) {
            // Not valid JSON, continue to text parsing
            console.log("Linter data is not JSON, trying text format parsing");
        }

        // Parse as text format (solhint output)
        return parseTextBasedLinterOutput(linterData);
    } catch (error) {
        console.error('Error parsing linter data:', error);
        return [];
    }
}

/**
 * Helper function to get rule category based on its ID.
 * 
 * @param ruleId The rule ID to look up
 * @returns The category of the rule
 */
function getRuleCategory(ruleId: string): Category {
    return solhintCategories[ruleId] || "Miscellaneous";
}

/**
 * Helper function to format a rule ID for display.
 * 
 * @param ruleId The rule ID to format
 * @returns Formatted rule ID
 */
export function formatRuleId(ruleId: string): string {
    if (!ruleId) return "Unknown Rule";
    return ruleId
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

/**
 * Parses text-based linter output (like solhint CLI output)
 * 
 * @param linterText The text output from the linter
 * @returns An array of processed linter results
 */
function parseTextBasedLinterOutput(linterText: string): LinterResult[] {
    console.log("Parsing text-based linter output");
    const results: LinterResult[] = [];

    // Split by newlines
    const lines = linterText.split('\n');
    let currentFile = '';

    for (const line of lines) {
        // Skip empty lines or summary/footer lines
        if (!line.trim() ||
            line.includes('problems') ||
            line.includes('----------') ||
            line.includes('===>')) {
            continue;
        }

        // Check if this is a file name line (ends with .sol without any spaces/numbers after it)
        // This improved regex will match file names more reliably
        if (/^\s*([^\s:]+\.sol)\s*$/.test(line.trim())) {
            currentFile = line.trim();
            console.log(`Found file header in linter output: ${currentFile}`);
            continue;
        }

        // Parse issue lines with more flexible regex to handle various formats
        const match = line.match(/\s*(\d+):(\d+)\s+(warning|error)\s+([^]+?)(\S+)?$/);
        if (match && currentFile) {
            const lineNumber = parseInt(match[1], 10);
            const column = parseInt(match[2], 10);
            const level = match[3];
            const message = match[4] ? match[4].trim() : 'Unknown issue';

            // Extract rule ID from the end of the line
            let ruleId = match[5] ? match[5].trim() : 'unknown-rule';

            // Handle truncated rule IDs
            if (ruleId.endsWith('…')) {
                const prefix = ruleId.replace('…', '');
                const matchingRules = Object.keys(solhintCategories).filter(id =>
                    id.startsWith(prefix));
                if (matchingRules.length === 1) {
                    ruleId = matchingRules[0];
                }
            }

            // Add the result with file information
            results.push({
                filePath: currentFile,
                line: lineNumber,
                column: column,
                severity: level === 'error' ? 2 : 1,
                message: message,
                ruleId: ruleId,
                category: getRuleCategory(ruleId)
            });
        }
    }

    console.log(`Parsed ${results.length} linter issues across multiple files`);

    // Debug: Log file distribution
    const fileDistribution: Record<string, number> = {};
    results.forEach(result => {
        const file = result.filePath || 'Unknown';
        fileDistribution[file] = (fileDistribution[file] || 0) + 1;
    });
    console.log('Linter issues distribution by file:', fileDistribution);

    return results;
}

